//! 完整集成测试
//! 包含交易流程、RPC故障转移、通知系统等完整测试

use std::sync::Arc;

use ironcore::{
    app_state::AppState,
    infrastructure::{audit::ImmuCtx, cache::RedisCtx},
    service::{
        blockchain_client::BlockchainClient, fee_service::FeeService, rpc_selector::RpcSelector,
    },
};
use sqlx::PgPool;
use uuid::Uuid;

// ============ 测试辅助函数 ============

/// 创建测试用的 AppState（使用真实数据库）
async fn create_test_app_state() -> Arc<AppState> {
    let database_url = std::env::var("TEST_DATABASE_URL")
        .unwrap_or_else(|_| "postgres://root@localhost:26257/ironcore?sslmode=disable".into());

    let pool = sqlx::postgres::PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await
        .expect("Failed to connect to test database");

    let redis_url =
        std::env::var("TEST_REDIS_URL").unwrap_or_else(|_| "redis://localhost:6379".into());
    let redis = Arc::new(RedisCtx::new(&redis_url).expect("Failed to create Redis client"));

    let immu = Arc::new(ImmuCtx::new(
        "127.0.0.1:3322".into(),
        "immudb".into(),
        "immudb".into(),
        "defaultdb".into(),
    ));

    Arc::new(AppState::new(pool, (*redis).clone(), immu))
}

/// 清理测试数据
async fn cleanup_test_data(pool: &PgPool, user_id: Uuid) {
    let _ = sqlx::query("DELETE FROM gas.fee_audit WHERE user_id = $1")
        .bind(user_id)
        .execute(pool)
        .await;

    let _ = sqlx::query("DELETE FROM users WHERE id = $1")
        .bind(user_id)
        .execute(pool)
        .await;
}

/// 创建测试用户
async fn create_test_user(pool: &PgPool) -> Uuid {
    let user_id = Uuid::new_v4();
    let tenant_id = Uuid::new_v4();

    let _ = sqlx::query(
        "INSERT INTO tenants (id, name) VALUES ($1, $2) 
         ON CONFLICT (id) DO NOTHING",
    )
    .bind(tenant_id)
    .bind("Test Tenant")
    .execute(pool)
    .await;

    sqlx::query(
        "INSERT INTO users (id, tenant_id, email_cipher, role, password_hash) 
         VALUES ($1, $2, $3, $4, $5)",
    )
    .bind(user_id)
    .bind(tenant_id)
    .bind("test@example.com")
    .bind("user")
    .bind("$2b$12$dummy_hash")
    .execute(pool)
    .await
    .expect("Failed to create test user");

    user_id
}

// ============ 集成测试 ============

#[tokio::test]
#[ignore] // 需要真实数据库
async fn test_complete_fee_calculation_flow() {
    let state = create_test_app_state().await;
    let user_id = create_test_user(&state.pool).await;

    // 1. 创建费率规则
    let rule_id = Uuid::new_v4();
    sqlx::query(
        "INSERT INTO gas.platform_fee_rules 
         (id, chain, operation, fee_type, flat_amount, percent_bp, min_fee, priority, rule_version, active)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, true)"
    )
    .bind(rule_id)
    .bind("eth")
    .bind("transfer")
    .bind("percent")
    .bind(0.0)
    .bind(50) // 0.5%
    .bind(0.0001)
    .bind(10)
    .bind(1)
    .execute(&state.pool)
    .await
    .expect("Failed to create fee rule");

    // 2. 创建归集地址
    let collector_id = Uuid::new_v4();
    sqlx::query(
        "INSERT INTO gas.fee_collector_addresses (id, chain, address, active)
         VALUES ($1, $2, $3, true)",
    )
    .bind(collector_id)
    .bind("eth")
    .bind("0xFEE_COLLECTOR_ADDRESS_TEST")
    .execute(&state.pool)
    .await
    .expect("Failed to create collector address");

    // 3. 计算费用
    let fee_service = FeeService::with_redis(state.pool.clone(), state.redis.clone());
    let result = fee_service.calculate_fee("eth", "transfer", 100.0).await;

    assert!(result.is_ok());
    let calc = result.unwrap();
    assert!(calc.is_some());

    let fee_calc = calc.unwrap();
    assert_eq!(fee_calc.platform_fee, 0.5); // 100 * 0.5% = 0.5
    assert_eq!(fee_calc.collector_address, "0xFEE_COLLECTOR_ADDRESS_TEST");

    // 4. 记录审计
    let audit_result = fee_service
        .record_fee_audit(
            user_id,
            "eth",
            "transfer",
            100.0,
            &fee_calc,
            "0xUSER_WALLET_ADDRESS",
            Some("0x1234567890abcdef"),
        )
        .await;

    assert!(audit_result.is_ok());

    // 5. 验证审计记录
    let audit_count: i64 =
        sqlx::query_scalar("SELECT COUNT(*) FROM gas.fee_audit WHERE user_id = $1")
            .bind(user_id)
            .fetch_one(&state.pool)
            .await
            .expect("Failed to query audit records");

    assert_eq!(audit_count, 1);

    // 清理
    cleanup_test_data(&state.pool, user_id).await;
    let _ = sqlx::query("DELETE FROM gas.platform_fee_rules WHERE id = $1")
        .bind(rule_id)
        .execute(&state.pool)
        .await;
    let _ = sqlx::query("DELETE FROM gas.fee_collector_addresses WHERE id = $1")
        .bind(collector_id)
        .execute(&state.pool)
        .await;
}

#[tokio::test]
#[ignore]
async fn test_rpc_failover_integration() {
    let state = create_test_app_state().await;

    // 1. 清理现有端点
    let _ = sqlx::query("DELETE FROM admin.rpc_endpoints WHERE chain = 'eth_test'")
        .execute(&state.pool)
        .await;

    // 2. 创建多个测试RPC端点
    let endpoints = vec![
        ("https://eth-mainnet.g.alchemy.com/v2/demo", 10, true),
        ("https://rpc.ankr.com/eth", 20, true),
        ("https://cloudflare-eth.com", 30, false), // 禁用的端点
    ];

    for (url, priority, enabled) in endpoints {
        sqlx::query(
            "INSERT INTO admin.rpc_endpoints (id, chain, url, priority, healthy, fail_count, circuit_state)
             VALUES (gen_random_uuid(), $1, $2, $3, $4, 0, 'closed')"
        )
        .bind("eth_test")
        .bind(url)
        .bind(priority as i32)
        .bind(enabled)
        .execute(&state.pool)
        .await
        .expect("Failed to insert RPC endpoint");
    }

    // 3. 创建 RPC 选择器
    let selector = RpcSelector::new(state.pool.clone());
    selector
        .load_endpoints()
        .await
        .expect("Failed to load endpoints");

    // 4. 选择端点（应该选择优先级最高且启用的）
    let endpoint = selector.select("eth_test").await;
    assert!(endpoint.is_some());

    let selected = endpoint.unwrap();
    assert_eq!(selected.priority, 10); // 最高优先级
    assert!(selected.url.contains("alchemy"));

    // 5. 记录失败（模拟故障）
    for _ in 0..3 {
        selector.record_failure(&selected.id).await;
    }

    // 6. 再次选择（应该切换到备用）
    let fallback_endpoint = selector.select("eth_test").await;
    assert!(fallback_endpoint.is_some());

    let fallback = fallback_endpoint.unwrap();
    assert_eq!(fallback.priority, 20); // 次高优先级
    assert!(fallback.url.contains("ankr"));

    // 7. 验证断路器状态
    let circuit_state: String =
        sqlx::query_scalar("SELECT circuit_state FROM admin.rpc_endpoints WHERE url = $1")
            .bind("https://eth-mainnet.g.alchemy.com/v2/demo")
            .fetch_one(&state.pool)
            .await
            .expect("Failed to query circuit state");

    assert_eq!(circuit_state, "open"); // 应该打开断路器

    // 清理
    let _ = sqlx::query("DELETE FROM admin.rpc_endpoints WHERE chain = 'eth_test'")
        .execute(&state.pool)
        .await;
}

#[tokio::test]
#[ignore]
async fn test_notification_publish_and_feed() {
    let state = create_test_app_state().await;
    let user_id = create_test_user(&state.pool).await;

    // 1. 发布通知
    let notif_id = Uuid::new_v4();
    sqlx::query(
        "INSERT INTO notify.notifications (id, tenant_id, category, title, content, severity, target_roles, published_by)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8)"
    )
    .bind(notif_id)
    .bind(Uuid::new_v4())
    .bind("system_update")
    .bind("Test Notification")
    .bind("This is a test notification content")
    .bind("info")
    .bind(sqlx::types::Json(vec!["user", "admin"]))
    .bind(user_id)
    .execute(&state.pool)
    .await
    .expect("Failed to publish notification");

    // 2. 查询通知（分页）
    let notifications = sqlx::query(
        "SELECT id, category, title, content, severity, published_at 
         FROM notify.notifications 
         WHERE category = $1
         ORDER BY published_at DESC
         LIMIT 10 OFFSET 0",
    )
    .bind("system_update")
    .fetch_all(&state.pool)
    .await
    .expect("Failed to fetch notifications");

    assert!(!notifications.is_empty());
    assert_eq!(notifications.len(), 1);

    // 3. 验证通知内容
    let row = &notifications[0];
    let title: String = row.get("title");
    let content: String = row.get("content");
    let severity: String = row.get("severity");

    assert_eq!(title, "Test Notification");
    assert_eq!(content, "This is a test notification content");
    assert_eq!(severity, "info");

    // 清理
    let _ = sqlx::query("DELETE FROM notify.notifications WHERE id = $1")
        .bind(notif_id)
        .execute(&state.pool)
        .await;
    cleanup_test_data(&state.pool, user_id).await;
}

#[tokio::test]
#[ignore]
async fn test_fee_cache_expiration() {
    let state = create_test_app_state().await;

    // 1. 创建费率规则
    let rule_id = Uuid::new_v4();
    sqlx::query(
        "INSERT INTO gas.platform_fee_rules 
         (id, chain, operation, fee_type, flat_amount, percent_bp, min_fee, priority, rule_version, active)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, true)"
    )
    .bind(rule_id)
    .bind("btc")
    .bind("transfer")
    .bind("flat")
    .bind(0.0001)
    .bind(0)
    .bind(0.0)
    .bind(10)
    .bind(1)
    .execute(&state.pool)
    .await
    .expect("Failed to create fee rule");

    let collector_id = Uuid::new_v4();
    sqlx::query(
        "INSERT INTO gas.fee_collector_addresses (id, chain, address, active)
         VALUES ($1, $2, $3, true)",
    )
    .bind(collector_id)
    .bind("btc")
    .bind("bc1qcollector_test_address")
    .execute(&state.pool)
    .await
    .expect("Failed to create collector");

    // 2. 第一次查询（从数据库）
    let fee_service = FeeService::with_redis(state.pool.clone(), state.redis.clone());
    let start = std::time::Instant::now();
    let result1 = fee_service
        .calculate_fee("btc", "transfer", 1.0)
        .await
        .unwrap();
    let db_time = start.elapsed();

    // 3. 第二次查询（从缓存）
    let start = std::time::Instant::now();
    let result2 = fee_service
        .calculate_fee("btc", "transfer", 1.0)
        .await
        .unwrap();
    let cache_time = start.elapsed();

    // 验证缓存比数据库快
    assert!(cache_time < db_time);

    // 验证结果一致
    assert_eq!(
        result1.as_ref().unwrap().platform_fee,
        result2.as_ref().unwrap().platform_fee
    );

    // 清理
    let _ = sqlx::query("DELETE FROM gas.platform_fee_rules WHERE id = $1")
        .bind(rule_id)
        .execute(&state.pool)
        .await;
    let _ = sqlx::query("DELETE FROM gas.fee_collector_addresses WHERE id = $1")
        .bind(collector_id)
        .execute(&state.pool)
        .await;
}

#[tokio::test]
#[ignore]
async fn test_transaction_broadcast_retry() {
    let state = create_test_app_state().await;

    // 注意：这个测试需要 mock RPC 端点或使用测试网
    // 这里仅测试重试机制的逻辑

    let blockchain_client = BlockchainClient::new(state.pool.clone());

    // 创建测试 RPC 端点（模拟）
    let _ = sqlx::query("DELETE FROM admin.rpc_endpoints WHERE chain = 'eth_retry_test'")
        .execute(&state.pool)
        .await;

    sqlx::query(
        "INSERT INTO admin.rpc_endpoints (id, chain, url, priority, healthy, circuit_state)
         VALUES (gen_random_uuid(), $1, $2, 10, true, 'closed')",
    )
    .bind("eth_retry_test")
    .bind("https://mock-rpc-endpoint.local") // 无效端点，会触发重试
    .execute(&state.pool)
    .await
    .expect("Failed to insert mock endpoint");

    // 尝试广播（会失败并重试）
    let broadcast_req =
        ironforge_backend::service::blockchain_client::BroadcastTransactionRequest {
            chain: "eth_retry_test".to_string(),
            raw_tx: "0xf86c0a8502540be40082520894...".to_string(), // 示例交易
            from_address: "0xSENDER".to_string(),
            to_address: Some("0xRECEIVER".to_string()),
            value: "1.0".to_string(),
            gas_limit: "21000".to_string(),
            gas_price: Some("20000000000".to_string()),
        };

    let result = blockchain_client.broadcast_transaction(broadcast_req).await;

    // 由于是 mock 端点，预期失败
    assert!(result.is_err());

    // 验证重试次数（应该有3次失败记录）
    let fail_count: i64 =
        sqlx::query_scalar("SELECT SUM(fail_count) FROM admin.rpc_endpoints WHERE chain = $1")
            .bind("eth_retry_test")
            .fetch_one(&state.pool)
            .await
            .unwrap_or(0);

    assert!(fail_count > 0); // 至少有失败记录

    // 清理
    let _ = sqlx::query("DELETE FROM admin.rpc_endpoints WHERE chain = 'eth_retry_test'")
        .execute(&state.pool)
        .await;
}

#[tokio::test]
#[ignore]
async fn test_multi_chain_fee_calculation() {
    let state = create_test_app_state().await;

    // 为多条链创建费率规则
    let chains = vec![
        ("eth", 50, 0.0001),   // 0.5%, min 0.0001 ETH
        ("bsc", 30, 0.00005),  // 0.3%, min 0.00005 BNB
        ("polygon", 20, 0.01), // 0.2%, min 0.01 MATIC
    ];

    for (chain, percent_bp, min_fee) in chains {
        let rule_id = Uuid::new_v4();
        sqlx::query(
            "INSERT INTO gas.platform_fee_rules 
             (id, chain, operation, fee_type, percent_bp, min_fee, priority, rule_version, active)
             VALUES ($1, $2, 'transfer', 'percent', $3, $4, 10, 1, true)",
        )
        .bind(rule_id)
        .bind(chain)
        .bind(percent_bp as i32)
        .bind(min_fee)
        .execute(&state.pool)
        .await
        .expect("Failed to create multi-chain rule");

        let collector_id = Uuid::new_v4();
        sqlx::query(
            "INSERT INTO gas.fee_collector_addresses (id, chain, address, active)
             VALUES ($1, $2, $3, true)",
        )
        .bind(collector_id)
        .bind(chain)
        .bind(format!("0x{}_COLLECTOR", chain.to_uppercase()))
        .execute(&state.pool)
        .await
        .expect("Failed to create collector");
    }

    // 测试每条链的费用计算
    let fee_service = FeeService::with_redis(state.pool.clone(), state.redis.clone());

    let eth_fee = fee_service
        .calculate_fee("eth", "transfer", 100.0)
        .await
        .unwrap()
        .unwrap();
    assert_eq!(eth_fee.platform_fee, 0.5); // 100 * 0.5%

    let bsc_fee = fee_service
        .calculate_fee("bsc", "transfer", 100.0)
        .await
        .unwrap()
        .unwrap();
    assert_eq!(bsc_fee.platform_fee, 0.3); // 100 * 0.3%

    let polygon_fee = fee_service
        .calculate_fee("polygon", "transfer", 10.0)
        .await
        .unwrap()
        .unwrap();
    assert_eq!(polygon_fee.platform_fee, 0.02); // 10 * 0.2%

    // 测试最小费用保障
    let small_eth = fee_service
        .calculate_fee("eth", "transfer", 0.01)
        .await
        .unwrap()
        .unwrap();
    assert_eq!(small_eth.platform_fee, 0.0001); // 应该使用 min_fee

    // 清理
    let _ =
        sqlx::query("DELETE FROM gas.platform_fee_rules WHERE chain IN ('eth', 'bsc', 'polygon')")
            .execute(&state.pool)
            .await;
    let _ = sqlx::query(
        "DELETE FROM gas.fee_collector_addresses WHERE chain IN ('eth', 'bsc', 'polygon')",
    )
    .execute(&state.pool)
    .await;
}

#[tokio::test]
async fn test_config_loading_from_env() {
    // 设置环境变量
    std::env::set_var(
        "JWT_SECRET",
        "test_secret_key_for_jwt_signing_at_least_32_chars",
    );
    std::env::set_var("DATABASE_URL", "postgres://test@localhost/test");

    use ironcore::config::Config;

    let config = Config::from_env();
    assert!(config.is_ok());

    let cfg = config.unwrap();
    assert_eq!(cfg.database.url, "postgres://test@localhost/test");
    assert!(cfg.jwt.secret.len() >= 32);
}

#[tokio::test]
async fn test_fee_calculation_edge_cases() {
    // 测试边界情况（不需要数据库）

    // 测试零值
    let amount = 0.0;
    let percent_bp = 50;
    let fee = amount * (percent_bp as f64) / 10_000.0;
    assert_eq!(fee, 0.0);

    // 测试极小值
    let amount = 0.0001;
    let fee = amount * (percent_bp as f64) / 10_000.0;
    assert!(fee > 0.0);
    assert!(fee < 0.001);

    // 测试大额
    let amount = 1_000_000.0;
    let fee = amount * (percent_bp as f64) / 10_000.0;
    assert_eq!(fee, 50.0); // 1M * 0.5% = 5000

    // 测试最大封顶
    let max_fee = 10.0;
    let calculated_fee = 50.0;
    let final_fee = calculated_fee.min(max_fee);
    assert_eq!(final_fee, 10.0);
}
